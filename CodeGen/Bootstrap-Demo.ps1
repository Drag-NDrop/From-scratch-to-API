
<# 
This script will: 
 * Create a new project
 * Alter the .csproj file to disable culture invariance
 * Bootstrap dependencies(Automatically add NuGet packages to the project)
 * Scaffold the Entity Framework models
 * Add a connection string to the appsettings.json file
 * Scaffold API endpoint CRUD operations
 * And update the program file, to add and map the controllers generated by the API scaffolding

 * Keep in mind, that there's no error handling in this script, so if something goes wrong, you'll have to debug it yourself.
 * Also, this script is not meant to be run in a production environment, as it's only a proof of concept.
 * It's meant to be run in a development environment, where you can easily revert changes if something goes wrong.
 * It's also meant to be run in a clean environment, as it will create a new project and add a lot of dependencies to it.
 * Lastly, it was created in a single evening/night, and it shows.. :-)
#>

# Define the project variables. We pass these around to the different functions.
# This should be your starting point, if debugging becomes necessary.

# ==> Project variables <==
$PathToYourNewProject = 'D:\LiveDemoForKlassen-TesterJWT'
$NewProjectName = "GoSave"
$DbContextName = "GoSaveContext"
# ==> Database variables <==
$connectionString = "Server=10.10.10.13;Initial Catalog=db_gosave;Persist Security Info=False;User ID=GoSave-dbadmin;Password=Temp1234!!;Connection Timeout=30"
$frameworkVersionTarget = "net8.0" # Used when creating the new project. Other valid values: net5.0, net6.0
$providerTarget = "MariaDB" # Other valid values MSSQL, MariaDB, MySQL # This is the DBMS You're using
$InstallJWT = $true # If you want to install JWT, set this to true. If not, set it to false.
$JwtSettings= @()
if ($InstallJWT) {
    $JwtSettings = @(
        # https://medium.com/@vndpal/how-to-implement-jwt-token-authentication-in-net-core-6-ab7f48470f5c
        @{ TaskName='SetupJWT-Install'; PackageInformation='Microsoft.AspNetCore.Authentication.JwtBearer'; Version='8.0.4' },
        @{ TaskName='SetupJWT-Install'; PackageInformation='System.IdentityModel.Tokens.Jwt'; Version='7.5.1' },
        @{ TaskName='SetupJWT-Options'; JwtKey=(New-Guid).Guid; Issuer='yourCompanyIssuer.com' },
        
        @{ TaskName='SetupJWT-User'; JwtUsername='Api-Admin'; JwtPassword=(New-Guid).Guid;},
        @{ TaskName='SetupJWT-Choice'; Name='Protect-Get'; Choice='yes' },
        @{ TaskName='SetupJWT-Choice'; Name='Protect-GetById'; Choice='yes' },
        @{ TaskName='SetupJWT-Choice'; Name='Protect-Post'; Choice='yes' },
        @{ TaskName='SetupJWT-Choice'; Name='Protect-PutById'; Choice='yes' },
        @{ TaskName='SetupJWT-Choice'; Name='Protect-DeleteById'; Choice='yes' }
    )
}

$dependencyArray = @(
    @{ Name="Microsoft.EntityFrameworkCore"; Version="8.0.2" },
    @{ Name="Microsoft.EntityFrameworkCore.Tools"; Version="8.0.2" },
    @{ Name="Microsoft.VisualStudio.Web.CodeGeneration.Design"; Version="8.0.1" },
    @{ Name="Microsoft.EntityFrameworkCore.SqlServer"; Version="8.0.2" }
    
)
switch ($providerTarget) {
    "MSSQL"   { 
        $providerTarget = "Microsoft.EntityFrameworkCore.SqlServer"
    }
    "MariaDB" { 
        $dependencyArray += @{ Name="Pomelo.EntityFrameworkCore.MySql"; Version="8.0.2" } 
        $providerTarget = "Pomelo.EntityFrameworkCore.MySql"
    }
    "MySQL"   { 
        $dependencyArray += @{ Name="MySql.Data.EntityFrameworkCore"; Version="8.0.2" } 
        $providerTarget = "MySql.Data.EntityFrameworkCore"
    }
    Default {
        Write-Host "Invalid provider target. Please choose between 'MSSQL', 'MariaDB' or 'MySQL'"
        Write-Host "The script wont work properly when a valid provider target is not chosen."
        Exit
    }
}

if($InstallJWT -eq $true){
    foreach($setting in $JwtSettings){
        if($setting.TaskName -eq 'SetupJWT-Install'){
            $dependencyArray += @{ Name=$setting.PackageInformation; Version=$setting.Version }
        }
    
    }
}
# Import the functions. In Powershell, this is known as Dot-sourcing a script.
# It's a way to include the functions from another script, so we can use them in this script.
# This is the reason why we can call the functions without having to define them in this script.
# It's mainly done for readability, as it makes the script easier to read and understand.
. './Functions/Create-NewProject.ps1'
. './Functions/Update-ConnectionStringInAppSettings.ps1'
. './Functions/Bootstrap-dependencies.ps1'
. './Functions/Scaffold-EntityModels.ps1'
. './Functions/Update-ProgramFile.ps1'
. './Functions/Scaffold-API-MinimalCRUD.ps1'
if( $InstallJWT ) {
    . './Functions/Optional-InstallJWT.ps1'
    . './Functions/Update-JWTInAppSettings.ps1'
    . './Functions/Update-APIInAppSettings.ps1'
    . './Functions/Create-JwtLoginController.ps1'
}


# Create a new project from a .Net Core Web API template
# Please note that the accent grave ` is used to escape the newline character, so the command can be written on multiple lines.
# This is done for readability, as it makes the script easier to read and understand.
Create-NewProject -newProjectName $newProjectName `
                  -pathToYourProjectDirectory $PathToYourNewProject `
                  -framework $frameworkVersionTarget `
                  -DisableCultureInvariance
# Right after, update the connectionstring in the appsettings.json file
Update-ConnectionStringInAppSettings -projectPath "$(Join-Path $PathToYourNewProject $NewProjectName)" `
                                    -connectionString $connectionString `
                                    -connectionName $DbContextName

if( $InstallJWT ) {
    $JwtTask = $JwtSettings | Where-Object { $_.TaskName -eq 'SetupJWT-Options' }
    Update-JwtInAppSettings -projectPath "$(Join-Path $PathToYourNewProject $NewProjectName)" `
                            -Key $JwtTask.JwtKey `
                            -Issuer $JwtTask.Issuer

}


# Get the path to the project file
$pathToYourProjectFile = Get-ChildItem -Path $PathToYourNewProject -Filter *.csproj -Recurse | Select-Object -First 1
$projectPath = "$PathToYourNewProject\$newProjectName"



# Bootstrap the project with the necessary dependencies. This will add NuGet packages to the project.
<# The packages are: 
    Microsoft.EntityFrameworkCore,                     => For Entity Framework Core
    Microsoft.EntityFrameworkCore.Design,              => To be able to scaffold the models and API
    Microsoft.EntityFrameworkCore.SqlServer,           => To provide support for SQL Server
    "Microsoft.VisualStudio.Web.CodeGeneration.Design  => To be able to scaffold the API
#>
Bootstrap-Dependencies -csProjPath $pathToYourProjectFile.FullName -dependencyArray $dependencyArray

# Scaffold the entity models and API
Write-host "Project path: $ProjectPath"
Write-host "Connection string: $connectionString"
Write-host "DbContextName: $DbContextName"
# Splat the parameters for the Scaffold-EntityModels function
$params = @{
    projectPath       = $ProjectPath
    connectionString  = $connectionString
    outputDir         = "Models"
    provider          = $providerTarget
    context           = $DbContextName
    contextDir        = "Context"
}
Scaffold-EntityModels @params

# Scaffold the API with minimal CRUD operations
Scaffold-API-MinimalCRUD -projectPath $projectPath -dbContextName $DbContextName

# Splat the parameters for the Update-ProgramFile function
$updateProgramParams = @{
    projectPath = $projectPath
    projectName = $NewProjectName
    providerTarget = $providerTarget
    connectionStringName = $DbContextName
    dbContextName = $DbContextName
    InstallJWT = $InstallJWT
}
Update-ProgramFile @updateProgramParams




###############################
# Test bed - only F8 from here
##############################


if( $InstallJWT ) {
    # Insert the API credentials in the appsettings.json file
    $JwtTask = $JwtSettings | Where-Object { $_.TaskName -eq 'SetupJWT-Options' }
    Update-JwtInAppSettings -projectPath "$PathToYourNewProject`\$newProjectName" `
                            -Key $JwtTask.JwtKey `
                            -Issuer $JwtTask.Issuer
    # Insert the API-user credentials in the appsettings.json file
    $JwtTask = $JwtSettings | Where-Object { $_.TaskName -eq 'SetupJWT-User' }
    Update-APIInAppSettings -projectPath "$PathToYourNewProject`\$newProjectName" `
                            -APIUser $JwtTask.JwtUsername `
                            -APIPassword $JwtTask.JwtPassword

    $ControllerFolder = "$PathToYourNewProject`\$newProjectName`\Controllers"
    Create-JwtLoginController -ControllerFolderPath $ControllerFolder
}


<# Next:
# Disse skal tilføjes:
    * En mekanisme der looper gennem controllers, og protecter de controllers der er angivet i JwtSettings



$AddThisToProgramFileForSwaggerAuthSupport => Program.cs -> Done
$AddThisToProgramFile => Program.cs -> Done
$JwtLoginController => Controllers/JwtLoginController.cs (Ny fil) -> Done


#>


# V2 notes:
# Find ud af hvordan vi auto implementer et repository pattern?
# Find ud af hvordan vi auto implementer en unit of work pattern?
# Vi skal kunne abstracte os ud af at være låst til en specifik database provider ^